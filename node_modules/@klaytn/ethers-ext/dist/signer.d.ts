import { Signer as EthersSigner, TypedDataDomain, TypedDataField } from "@ethersproject/abstract-signer";
import { Bytes } from "@ethersproject/bytes";
import { ProgressCallback } from "@ethersproject/json-wallets";
import { Deferrable } from "@ethersproject/properties";
import { JsonRpcProvider as EthersJsonRpcProvider, JsonRpcSigner as EthersJsonRpcSigner, Provider, TransactionRequest, TransactionResponse } from "@ethersproject/providers";
import { Wallet as EthersWallet } from "@ethersproject/wallet";
import { PrivateKeyLike } from "./types";
export declare class Wallet extends EthersWallet {
    static fromEncryptedJson(json: string, password: string | Bytes, progress?: ProgressCallback): Promise<Wallet>;
    static fromEncryptedJsonSync(json: string, password: string | Bytes): Wallet;
    static fromEncryptedJsonList(json: string, password: string | Bytes, progress?: ProgressCallback): Promise<Wallet[]>;
    static fromEncryptedJsonListSync(json: string, password: string | Bytes): Wallet[];
    private klaytnAddr;
    constructor(addressOrPrivateKey: string | PrivateKeyLike, privateKeyOrProvider?: PrivateKeyLike | Provider, provider?: Provider);
    getAddress(legacy?: boolean): Promise<string>;
    getEtherAddress(): Promise<string>;
    decodeTxFromRLP(rlp: string): any;
    isDecoupled(): Promise<boolean>;
    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest>;
    populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest>;
    private _populateTransaction;
    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    signTransactionAsFeePayer(transactionOrRLP: Deferrable<TransactionRequest> | string): Promise<string>;
    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
    sendTransactionAsFeePayer(transactionOrRLP: Deferrable<TransactionRequest> | string): Promise<TransactionResponse>;
    _sendKlaytnRawTransaction(signedTx: string): Promise<TransactionResponse>;
}
export declare class JsonRpcSigner extends EthersSigner implements EthersJsonRpcSigner {
    readonly provider: EthersJsonRpcProvider;
    _index: number;
    _address: string;
    constructor(provider: EthersJsonRpcProvider, addressOrIndex?: string | number);
    isKaikas(): boolean;
    getAddress(): Promise<string>;
    connect(_provider: Provider): EthersJsonRpcSigner;
    connectUnchecked(): EthersJsonRpcSigner;
    signMessage(message: string | Bytes): Promise<string>;
    _legacySignMessage(message: Bytes | string): Promise<string>;
    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;
    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest>;
    populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest>;
    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    unlock(password: string): Promise<boolean>;
}
//# sourceMappingURL=signer.d.ts.map